input AdvertisementPostInputType {
  book: BookCreationInput = null
  images: [String!]!
  isbn: String!
  price: Float!
}

type AdvertisementType {
  book: Book!
  bookID: String!
  id: String!
  images: [String!]!
  open: Boolean!
  price: Int!
  seller: UserType!
  sellerID: String!
  time: String!
}

input AdvertisementTypeListRelationFilter {
  every: AdvertisementTypeWhereInput
  none: AdvertisementTypeWhereInput
  some: AdvertisementTypeWhereInput
}

input AdvertisementTypeOrderByRelationAggregateInput {
  _count: SortOrder
}

input AdvertisementTypeOrderByWithRelationInput {
  book: BookOrderByWithRelationInput
  bookID: SortOrder
  id: SortOrder
  images: SortOrder
  open: SortOrder
  price: SortOrder
  seller: UserTypeOrderByWithRelationInput
  sellerID: SortOrder
  time: SortOrder
}

enum AdvertisementTypeScalarFieldEnum {
  bookID
  id
  images
  open
  price
  sellerID
  time
}

input AdvertisementTypeWhereInput {
  AND: [AdvertisementTypeWhereInput!]
  NOT: [AdvertisementTypeWhereInput!]
  OR: [AdvertisementTypeWhereInput!]
  book: BookRelationFilter
  bookID: StringFilter
  id: StringFilter
  images: StringNullableListFilter
  open: BoolFilter
  price: IntFilter
  seller: UserTypeRelationFilter
  sellerID: StringFilter
  time: StringFilter
}

input AdvertisementTypeWhereUniqueInput {
  id: String
}

type Book {
  _count: BookCount
  advertisements(cursor: AdvertisementTypeWhereUniqueInput, distinct: [AdvertisementTypeScalarFieldEnum!], orderBy: [AdvertisementTypeOrderByWithRelationInput!], skip: Int, take: Int, where: AdvertisementTypeWhereInput): [AdvertisementType!]!
  authorName: String!
  bookName: String!
  category: Category!
  categoryID: String!
  description: String!
  id: String!
  isbn: String!
  purchases: Int!
}

type BookCount {
  advertisements: Int!
}

input BookCreationInput {
  authorName: String!
  bookName: String!
  category: String!
  description: String!
  isbn: String!
}

input BookListRelationFilter {
  every: BookWhereInput
  none: BookWhereInput
  some: BookWhereInput
}

input BookOrderByRelationAggregateInput {
  _count: SortOrder
}

input BookOrderByWithRelationInput {
  advertisements: AdvertisementTypeOrderByRelationAggregateInput
  authorName: SortOrder
  bookName: SortOrder
  category: CategoryOrderByWithRelationInput
  categoryID: SortOrder
  description: SortOrder
  id: SortOrder
  isbn: SortOrder
  purchases: SortOrder
}

input BookRelationFilter {
  is: BookWhereInput
  isNot: BookWhereInput
}

enum BookScalarFieldEnum {
  authorName
  bookName
  categoryID
  description
  id
  isbn
  purchases
}

input BookWhereInput {
  AND: [BookWhereInput!]
  NOT: [BookWhereInput!]
  OR: [BookWhereInput!]
  advertisements: AdvertisementTypeListRelationFilter
  authorName: StringFilter
  bookName: StringFilter
  category: CategoryRelationFilter
  categoryID: StringFilter
  description: StringFilter
  id: StringFilter
  isbn: StringFilter
  purchases: IntFilter
}

input BookWhereUniqueInput {
  id: String
  isbn: String
}

input BoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

type Category {
  _count: CategoryCount
  books(cursor: BookWhereUniqueInput, distinct: [BookScalarFieldEnum!], orderBy: [BookOrderByWithRelationInput!], skip: Int, take: Int, where: BookWhereInput): [Book!]!
  description: String
  id: String!
  image: String!
  name: String!
}

type CategoryCount {
  books: Int!
}

input CategoryCreationInput {
  description: String
  image: String! = ""
  name: String!
}

input CategoryOrderByWithRelationInput {
  books: BookOrderByRelationAggregateInput
  description: SortOrder
  id: SortOrder
  image: SortOrder
  name: SortOrder
}

input CategoryRelationFilter {
  is: CategoryWhereInput
  isNot: CategoryWhereInput
}

input CategoryWhereInput {
  AND: [CategoryWhereInput!]
  NOT: [CategoryWhereInput!]
  OR: [CategoryWhereInput!]
  books: BookListRelationFilter
  description: StringNullableFilter
  id: StringFilter
  image: StringFilter
  name: StringFilter
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

type Mutation {
  createCategory(createCategoryInput: CategoryCreationInput!): Category!
  deleteUser: Boolean!
  loginUser(loginDetails: UserLoginType!): UserType
  postAdvertisement(postAdvertisement: AdvertisementPostInputType!): AdvertisementType!
  registerUser(registerDetails: UserRegisterType!): Boolean!
  updateUser(input: UserUpdateType!): UserType!
}

input NestedBoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  isSet: Boolean
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

type Query {
  getAllActiveAdvertisements: [AdvertisementType!]!
  getAllAdvertisements: [AdvertisementType!]!
  getAllCategories: [Category!]!
  getAllUsers: [UserType!]!
  getCurrentUser: UserType!
  getTrendingBooks: [Book!]!
}

enum QueryMode {
  default
  insensitive
}

enum SortOrder {
  asc
  desc
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  isSet: Boolean
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableListFilter {
  equals: [String!]
  has: String
  hasEvery: [String!]
  hasSome: [String!]
  isEmpty: Boolean
}

input UserLoginType {
  password: String!
  username: String!
}

input UserRegisterType {
  email: String!
  password: String!
  username: String!
}

type UserType {
  _count: UserTypeCount
  address: String
  ads(cursor: AdvertisementTypeWhereUniqueInput, distinct: [AdvertisementTypeScalarFieldEnum!], orderBy: [AdvertisementTypeOrderByWithRelationInput!], skip: Int, take: Int, where: AdvertisementTypeWhereInput): [AdvertisementType!]!
  email: String!
  fullName: String
  id: String!
  password: String!
  phoneNo: String
  username: String!
}

type UserTypeCount {
  ads: Int!
}

input UserTypeOrderByWithRelationInput {
  address: SortOrder
  ads: AdvertisementTypeOrderByRelationAggregateInput
  email: SortOrder
  fullName: SortOrder
  id: SortOrder
  password: SortOrder
  phoneNo: SortOrder
  username: SortOrder
}

input UserTypeRelationFilter {
  is: UserTypeWhereInput
  isNot: UserTypeWhereInput
}

input UserTypeWhereInput {
  AND: [UserTypeWhereInput!]
  NOT: [UserTypeWhereInput!]
  OR: [UserTypeWhereInput!]
  address: StringNullableFilter
  ads: AdvertisementTypeListRelationFilter
  email: StringFilter
  fullName: StringNullableFilter
  id: StringFilter
  password: StringFilter
  phoneNo: StringNullableFilter
  username: StringFilter
}

input UserUpdateType {
  address: String!
  email: String!
  fullName: String!
  phoneNo: String!
}